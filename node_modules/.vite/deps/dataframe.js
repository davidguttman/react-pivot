import {
  require_isIterateeCall
} from "./chunk-CDLHZE55.js";
import {
  require_find
} from "./chunk-QULOBC5U.js";
import "./chunk-OYHGFMIY.js";
import {
  require_baseRest,
  require_defineProperty
} from "./chunk-BAJENABD.js";
import "./chunk-XOKVFTIQ.js";
import {
  require_baseMap
} from "./chunk-X4CFZUYL.js";
import {
  require_baseEach
} from "./chunk-EN7EWJHV.js";
import {
  require_arrayLikeKeys,
  require_arrayPush,
  require_baseGet,
  require_baseIteratee,
  require_isArguments,
  require_isArray,
  require_isPrototype
} from "./chunk-AYTQVOFS.js";
import {
  require_isSymbol
} from "./chunk-AVVFB4Z6.js";
import {
  require_arrayMap,
  require_baseUnary,
  require_identity
} from "./chunk-RLWAKRWN.js";
import {
  require_Symbol,
  require_eq,
  require_isArrayLike,
  require_isObject
} from "./chunk-LDWJTFP4.js";
import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// node_modules/lodash/assignIn.js
var require_assignIn = __commonJS({
  "node_modules/lodash/assignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keysIn = require_keysIn();
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });
    module.exports = assignIn;
  }
});

// node_modules/lodash/extend.js
var require_extend = __commonJS({
  "node_modules/lodash/extend.js"(exports, module) {
    module.exports = require_assignIn();
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports, module) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module.exports = castFunction;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module.exports = forEach;
  }
});

// node_modules/lodash/each.js
var require_each = __commonJS({
  "node_modules/lodash/each.js"(exports, module) {
    module.exports = require_forEach();
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports, module) {
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports, module) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module.exports = baseOrderBy;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module.exports = sortBy;
  }
});

// node_modules/dataframe/index.js
var require_dataframe = __commonJS({
  "node_modules/dataframe/index.js"(exports, module) {
    var _ = {
      extend: require_extend(),
      each: require_each(),
      sortBy: require_sortBy(),
      find: require_find()
    };
    module.exports = function(opts) {
      return new DataFrame(opts);
    };
    function DataFrame(opts) {
      this.rows = opts.rows;
      this.dimensions = opts.dimensions;
      this.reduce = opts.reduce;
      this.cache = {};
      return this;
    }
    DataFrame.prototype.calculate = function(opts) {
      this.activeDimensions = opts.dimensions;
      if (this.activeDimensions.length < 1) this.activeDimensions = [""];
      this.sortBy = opts.sortBy;
      this.sortDir = opts.sortDir;
      this.filter = opts.filter;
      this.compact = opts.compact;
      var results = this.getResults();
      var resultRows = this.parseResults(results);
      return resultRows;
    };
    DataFrame.prototype.getResults = function() {
      var self = this;
      var columns = this.getColumns();
      var activeDimensions = this.activeDimensions;
      var filter = this.filter;
      var reduce = this.reduce;
      var results = {};
      var setKeyCache = {};
      this.rows.forEach(function(row) {
        var setKeys = self.createSetKeys(activeDimensions, row);
        var dVals = parseSetKey(setKeys[setKeys.length - 1]);
        if (filter && !filter(dVals)) return;
        var curLevel = results;
        setKeys.forEach(function(setKey, iLevel) {
          if (!curLevel[setKey]) {
            curLevel[setKey] = { value: {}, subDimensions: {}, key: setKey };
          }
          var result = curLevel[setKey].value;
          if (filter || !self.cache[setKey]) {
            if (!filter) setKeyCache[setKey] = result;
            _.extend(result, reduce(row, result));
            var dimensionVals = parseSetKey(setKey);
            _.extend(result, dimensionVals);
          } else {
            curLevel[setKey].value = self.cache[setKey];
          }
          curLevel = curLevel[setKey].subDimensions;
        });
      });
      _.each(setKeyCache, function(cache, key) {
        self.cache[key] = cache;
      });
      return results;
    };
    DataFrame.prototype.parseResults = function(results, level) {
      var self = this;
      var level = level || 0;
      var rows = [];
      var sorted = _.sortBy(results, this.getSortValue.bind(this));
      if (this.sortDir === "desc") sorted.reverse();
      _.each(sorted, function(dimension) {
        var total = dimension.value;
        total._level = level;
        total._key = dimension.key;
        var numSubDimensions = Object.keys(dimension.subDimensions).length;
        if (self.compact && numSubDimensions == 1) {
        } else {
          rows.push(total);
        }
        if (numSubDimensions) {
          var subLevel = self.compact && numSubDimensions == 1 ? level : level + 1;
          var subRows = self.parseResults(dimension.subDimensions, subLevel);
          subRows.forEach(function(subRow) {
            rows.push(subRow);
          });
        }
      });
      return rows;
    };
    DataFrame.prototype.getColumns = function() {
      var columns = [];
      this.dimensions.forEach(function(d) {
        columns.push({ type: "dimension", title: d, value: d });
      });
      return columns;
    };
    DataFrame.prototype.createSetKeys = function(dimensions, row) {
      var keys = [];
      for (var i = 0; i < dimensions.length; i++) {
        var sds = dimensions.slice(0, i + 1);
        keys.push(this.createSetKey(sds, row));
      }
      return keys;
    };
    DataFrame.prototype.createSetKey = function(dimensions, row) {
      var self = this;
      var key = "";
      _.sortBy(dimensions).forEach(function(dTitle) {
        var dimension = self.findDimension(dTitle);
        key += [dTitle, getValue(dimension, row)].join("ÿ") + "ÿ";
      });
      return key;
    };
    DataFrame.prototype.findDimension = function(title) {
      return _.find(this.dimensions, function(d) {
        return d.title === title;
      });
    };
    DataFrame.prototype.getSortValue = function(result) {
      var sortBy = this.sortBy;
      var columns = this.getColumns();
      var sortCol = _.find(columns, function(c) {
        return c.title === sortBy;
      }) || sortBy;
      var val = getValue(sortCol, result.value);
      if (typeof val === "undefined") return result.key;
      if (!isNaN(parseFloat(val)) && isFinite(val)) {
        return +val;
      } else if (typeof val === "string") {
        return val.toLowerCase();
      } else {
        return val;
      }
    };
    function parseSetKey(setKey) {
      var parsed = {};
      var kvPairs = setKey.split("ÿ");
      for (var i = 0; i < kvPairs.length; i += 2) {
        var dTitle = kvPairs[i];
        var dVal = kvPairs[i + 1];
        if (dTitle) parsed[dTitle] = dVal;
      }
      return parsed;
    }
    function getValue(col, row) {
      if (col == null) return null;
      if (typeof col === "string") {
        var val = row[col];
      } else if (typeof col === "function") {
        var val = col(row);
      } else if (typeof col.value === "string") {
        var val = row[col.value];
      } else {
        var val = col.value(row);
      }
      return val;
    }
  }
});
export default require_dataframe();
//# sourceMappingURL=dataframe.js.map
